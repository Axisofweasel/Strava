import pandas as pd
import requests as R
import json
import time
from ratelimit import limits, sleep_and_retry

limit_time = 900

class StravaApi:
    """ 
    
    collection of functions for interacting with the strava api and loading activities
      
    """    

# creates a standard formatted dataframe from the strava json output and overwrites the json into a new format

def initial_post(client_id:int, client_secret:str, code:str, file:str) -> json:
  
    grant_type = 'authorization_code'
    payload = {f"client_id":client_id,"client_secret":client_secret,"code":code,"grant_type":grant_type}
    url = R.post("https://www.strava.com/oauth/token?", params=payload)
    token_json = url.json()
    
    with open(file, 'w') as output_file:
        json.dump(token_json, output_file, indent=4)
    df = token_json
    return df



def cred_format(file:str, client_id:int, client_secret:str):
    """
    formats the json response from initial access request into basic access parameter json, dropps athlete details such as name etc. Original file is overwritten.
    
    Args:
        file (str): file path of json from first access token request
        client_id (int):

    Returns:
        Dataframe: Dataframe containing all the requisite access params for later requests
    """    '''
    '''
    with open(file) as data_file:
        obj = json.load(data_file)
        if 'athlete' in obj:
            cred = obj.copy()
            cred.pop('athlete')
        else:
            cred = obj
        cred['client_secret'] = client_secret
        cred['client_id'] = client_id
        
        with open(file, 'w') as output_file:
            json.dump(cred, output_file, indent=4)

    return cred


# checks access json to check expiry times

def refresh_check(file:str) -> bool:
    """Checks access json file to confirm whether refresh request needs to be used

    Args:
        file (str): path to access json generated by cred_format

    Returns:
        bool: True False value as to whether current credentials are expired or not. Evaluates false if tokens need to be refreshed
    """    
    with open(file, 'r') as data_file:
        obj = json.load(data_file)
        cred = pd.json_normalize(obj, max_level=0)
        expiry = cred['expires_at']
        curtime = time.time()
        thresholdtime = curtime - 3600
    return all(expiry > thresholdtime)

# refresh credemtials if necessary


def refresh_cred(file: str,) -> json:
    """Refreshes access token credentials if needed

    Args:
        file (str): path to access token json generated from cred_format

    Returns:
        json: returns a refreshed access token, expiry time and refresh token
    """    
    with open(file,'r') as data_file:
        access_obj = json.load(data_file)
        grant_type = 'refresh_token'
        refresh_token = access_obj['refresh_token']
        client_secret = access_obj['client_secret']
        client_id = access_obj['client_id']
        payload = {f"client_id":client_id,"client_secret":client_secret,"grant_type":grant_type,"refresh_token":refresh_token}
        url = R.post("https://www.strava.com/oauth/token", params=payload)
        refresh_json = url.json()
        access_obj['access_token'] = refresh_json['access_token']
        access_obj['expires_at'] = refresh_json['expires_at']
        access_obj['expires_in'] = refresh_json['expires_in']
        access_obj['refresh_token'] = refresh_json['refresh_token']
        with open(file, 'w') as output_file:
            json.dump(access_obj, output_file, indent=4)
    return access_obj


def access(file: str):
    
    with open(file,'r') as data_file:
        access_obj = json.load(data_file)
        client_id = access_obj['client_id']
        client_secret = access_obj['client_secret']
    
    cred_format(file, client_id, client_secret)
    print("-------------")
    print("...Formatting Credential File...")
    print("-------------")

    if not refresh_check(file):
        print("-------------")
        print("...Refreshing Credentials...")
        print("-------------")
        refresh_cred(file)
    else:
        print("-------------")
        print("Credentials Valid")
        print("-------------")
    return


def get_athleteid(cred_file:str, output_file:str = None):

##TODO: use this to pull datetimes for profile existence 
    with open(cred_file,'r') as data_file:
        access_obj = json.load(data_file)
        access_token = access_obj['access_token']
        
        payload = {"access_token":access_token}
        url = R.get("https://www.strava.com/api/v3/athlete", params=payload)
        response = url.json()
        rate_monitoring(url)
        if output_file is not None:
            with open(output_file, 'w') as file:
                json.dump(response, file, indent=4)
        df = pd.json_normalize(response, max_level=2)
    return df


def get_activities_total(cred_file:str, output_file:str = None):
    
    with open(cred_file,'r') as data_file:
        access_obj = json.load(data_file)
        access_token = access_obj['access_token']
        id = access_obj["client_id"]
        
        payload = {"access_token":access_token}
        url = R.get(f"https://www.strava.com/api/v3/athletes/402063/stats",params=payload)
        response = url.json()
        rate_monitoring(url)
        http_response(url)
        if  output_file is not None:
            with open(output_file,'w') as file:
                json.dump(response, file, indent=4)
        df=pd.json_normalize(response, max_level=2)
        
    return df

@sleep_and_retry
@limits(calls = 15, period = limit_time)
def get_activities(cred_file: str, per_page: int, page: int, output_file: str = None):

##TODO: use this to return all activities and create summary table of results
    with open(cred_file, 'r') as data_file:
        access_obj = json.load(data_file)
        access_token = access_obj['access_token']
        
        payload = {"access_token": access_token, "per_page": per_page, "page": page}
        url = R.get("https://www.strava.com/api/v3/athlete/activities", params= payload)
        response = url.json()
        rate_monitoring(url)
        http_response(url)
        if output_file is not None:
            with open(output_file, 'a') as file:
                json.dump(response, file, indent=4)
        df = pd.json_normalize(response, max_level=2)
    return df

def get_activities_v2(cred_file:str,activity_id:int, include_all_efforts:bool,output_file:str = None):

##TODO: use this to get each activitites details
  
    with open(cred_file,'r') as data_file:
        access_obj = json.load(data_file)
        access_token = access_obj['access_token']
        
        payload = {"access_token":access_token, "per_page":per_page,"page":page}
        url = R.get("https://www.strava.com/api/v3/athlete/activities", params=payload)
        response = url.json()
        rate_monitoring(url)
        if output_file is not None:
            with open(output_file, 'w') as file:
                json.dump(response, file, indent=4)
        df = pd.json_normalize(response, max_level=2)
        
    return df

def rate_monitoring(url_object):
    header = url_object.headers
    limit = header['X-Ratelimit-Limit']
    usage = header['X-RateLimit-Usage']
    limits = limit.split(",")
    usages = usage.split(",")
    print(f"quarter hour usage {usages[0]} of {limits[0]} ")
    print(f"quarter hour usage {usages[1]} of {limits[1]} ")
    return limits, usage

def http_response(url_object):
    status_code = url_object.status_code
    http_status_codes = {
        100: 'Continue',
        101: 'Switching Protocols',
        200: 'OK',
        201: 'Created',
        202: 'Accepted',
        203: 'Non-Authoritative Information',
        204: 'No Content',
        205: 'Reset Content',
        206: 'Partial Content',
        300: 'Multiple Choices',
        301: 'Moved Permanently',
        302: 'Found',
        303: 'See Other',
        304: 'Not Modified',
        305: 'Use Proxy',
        307: 'Temporary Redirect',
        308: 'Permanent Redirect',
        400: 'Bad Request',
        401: 'Unauthorized',
        402: 'Payment Required',
        403: 'Forbidden',
        404: 'Not Found',
        405: 'Method Not Allowed',
        406: 'Not Acceptable',
        407: 'Proxy Authentication Required',
        408: 'Request Timeout',
        409: 'Conflict',
        410: 'Gone',
        411: 'Length Required',
        412: 'Precondition Failed',
        413: 'Payload Too Large',
        414: 'URI Too Long',
        415: 'Unsupported Media Type',
        416: 'Range Not Satisfiable',
        417: 'Expectation Failed',
        418: 'Im a Teapot',
        429: 'Too Many Requests',
        500: 'Internal Server Error',
        501: 'Not Implemented',
        502: 'Bad Gateway',
        503: 'Service Unavailable',
        504: 'Gateway Timeout',
        505: 'HTTP Version Not Supported'
    }
    print(f"{status_code}: {http_status_codes.get(status_code, 'Unknown')}")